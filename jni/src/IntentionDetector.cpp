#include "IntentionDetector.h"

#include <thread> 
#include <future>

#include "json.hpp"
#include "ObjectControler.h"
#include "Intention.h"

IntentionDetector::IntentionDetector() {}
	
IntentionDetector::~IntentionDetector() {}

void IntentionDetector::setCallback(DetectorCallback pCallback) {
	m_pCallback = pCallback;
}

void IntentionDetector::reset() {
	ObjectControler::getInstance()->reset();
}

bool IntentionDetector::sendMessage(const char* pData) {
	//printf("send to detector: %s\n", pData);

	float fTimeStamp;
	float fPadding = 20;
	std::unordered_map<int, ObjectDetected> objects;
	std::unordered_map<int, ObjectDetected> platforms;

	nlohmann::json params = nlohmann::json::parse(pData);
	if (params.contains("timestamp")) {
		fTimeStamp = params["timestamp"];
	}
	else return false;
	if (params.contains("messagetype")) {
		int m_nMessageType = params["messagetype"];
		switch (m_nMessageType) {
		case 0:
			if (params.contains("padding")) {
				fPadding = params["padding"];
			}
			break;
		case 1:
			if (params.contains("objects") && params["objects"].is_array()) {
				nlohmann::json objectArray = params.at("objects");
				for (auto object : objectArray) {
					ObjectDetected obj;
					if (object.contains("position")) {
						obj.position[0] = object.at("position")[0];
						obj.position[1] = object.at("position")[1];
					}
					if (object.contains("velocity")) {
						obj.velocity[0] = object.at("velocity")[0];
						obj.velocity[1] = object.at("velocity")[1];
					}
					if (object.contains("id")) {
						obj.id = object["id"];
					}
					objects[obj.id] = obj;
				}
			}
			else return false;
			if (params.contains("platforms") && params["platforms"].is_array()) {
				nlohmann::json objectArray = params.at("platforms");
				for (auto object : objectArray) {
					ObjectDetected obj;
					if (object.contains("position")) {
						obj.position[0] = object.at("position")[0];
						obj.position[1] = object.at("position")[1];
					}
					if (object.contains("velocity")) {
						obj.velocity[0] = object.at("velocity")[0];
						obj.velocity[1] = object.at("velocity")[1];
					}
					if (object.contains("id")) {
						obj.id = object["id"];
					}
					platforms[obj.id] = obj;
				}
			}
			break;
		default:
			return false;
		}
	}
	else return false;

	ObjectControler::getInstance()->updatePlatforms(fTimeStamp, platforms);
	ObjectControler::getInstance()->updateMsgs(fTimeStamp, objects);
	if (!platforms.empty()) {
		ObjectControler::getInstance()->predict(platforms.begin()->first);
	}

	nlohmann::json output = ObjectControler::getInstance()->to_json();
	output["timestamp"] = fTimeStamp;
	if (m_pCallback) {
		m_pCallback(output.dump().c_str());
	}
}

const char* IntentionDetector::getCurrentSituation() {
	nlohmann::json output = ObjectControler::getInstance()->to_json();
	return output.dump().c_str();
}

struct AutoMoveThread {
	explicit AutoMoveThread() {}

	void run(DetectorCallback pCallback) {
		mAutoMoveThread = std::thread([this, pCallback]() {
			this->threadLoop(this->mExitSignal.get_future(), pCallback);
			});
		mAutoMoveThread.detach();
	}

	void stop() {
		mExitSignal.set_value();
	}

private:
	std::thread mAutoMoveThread;
	std::promise<void> mExitSignal;

	void threadLoop(std::future<void> exitListener, DetectorCallback pCallback) {
		std::shared_ptr<ObjectPlatform> pTarget = std::make_shared<ObjectPlatform>(-1, 500, 500);
		pTarget->setCurPos(Eigen::Vector2f(250, 250));

		std::unordered_map<int, std::shared_ptr<ObjectPlatform>> plats;
		plats[pTarget->getId()] = pTarget;
		ObjectControler::getInstance()->setPlatformData(plats);

		int eFleetType = (int)Object::FLEETType::Fleet_Herringborn;

		do {
			auto objs = GroupDetector::genObjects((Object::FLEETType)eFleetType, pTarget, 500, 500);

			eFleetType++;
			if (eFleetType >= (int)Object::FLEETType::Fleet_Unknow) eFleetType = 0;

			ObjectControler::getInstance()->setGenData(objs);
			Intention::getInstance()->reset();
			int count = 0;

			do {
				ObjectControler::getInstance()->autoMove();
				ObjectControler::getInstance()->predict(pTarget->getId());

				nlohmann::json output = ObjectControler::getInstance()->to_json();
				output["timestamp"] = 0;
				if (pCallback) {
					pCallback(output.dump().c_str());
				}

				std::this_thread::sleep_for(std::chrono::milliseconds(1));
				std::this_thread::yield();

				count++;
			} while (count <= 200);
		} while (exitListener.wait_for(std::chrono::microseconds(1)) == std::future_status::timeout);
	}
};

AutoMoveThread* stThread = nullptr;
void IntentionDetector::autoGenerateData(bool bStart) {
	if (bStart) {
		stThread = new AutoMoveThread();
		stThread->run(m_pCallback);
	}
	else {
		stThread->stop();
		delete stThread;
		stThread = nullptr;
	}
}

struct AutoSurroundThread {
	explicit AutoSurroundThread() {}

	void run(DetectorCallback pCallback) {
		mAutoSurroundThread = std::thread([this, pCallback]() {
			this->threadLoop(this->mExitSignal.get_future(), pCallback);
			});
		mAutoSurroundThread.detach();
	}

	void stop() {
		mExitSignal.set_value();
	}

private:
	std::thread mAutoSurroundThread;
	std::promise<void> mExitSignal;

	void threadLoop(std::future<void> exitListener, DetectorCallback pCallback) {
		std::shared_ptr<ObjectAI> pTarget = std::make_shared<ObjectAI>(1, 500, 500);
		pTarget->setCurPos(Eigen::Vector2f(250, 250));

		std::unordered_map<int, std::shared_ptr<ObjectAI>> plats;
		plats[pTarget->getId()] = pTarget;
		ObjectControler::getInstance()->setGenData(plats);

		int eFleetType = (int)Object::FLEETType::Fleet_Herringborn;

		do {
			int n = 8;
			float step = 360 / n;
			float angle = 0;
			int row = 500, col = 500;
			std::unordered_map<int, std::shared_ptr<ObjectPlatform>> objs;
			for (int i = 0; i < n; ++i) {

				std::shared_ptr<ObjectPlatform> object = std::make_shared<ObjectPlatform>(-i, row, col);

				Eigen::Vector2f pos = pTarget->getCurPos() + Eigen::Vector2f(std::cos(angle * EIGEN_PI / 180), -std::sin(angle * EIGEN_PI / 180)) * 40;
				object->setCurPos(pos);
				object->setSurroundAngle(angle);
				objs[-i] = object;

				angle += step;
			}

			eFleetType++;
			if (eFleetType >= (int)Object::FLEETType::Fleet_Unknow) eFleetType = 0;

			ObjectControler::getInstance()->setPlatformData(objs);
			Intention::getInstance()->reset();
			int count = 0;

			do {
				// ObjectControler::getInstance()->autoMove();
				ObjectControler::getInstance()->predict(pTarget->getId());

				nlohmann::json output = ObjectControler::getInstance()->to_json();
				output["timestamp"] = 0;
				if (pCallback) {
					pCallback(output.dump().c_str());
				}

				std::this_thread::sleep_for(std::chrono::milliseconds(1));
				std::this_thread::yield();

				count++;
			} while (count <= 200);
		} while (exitListener.wait_for(std::chrono::microseconds(1)) == std::future_status::timeout);
	}
};

AutoSurroundThread* stSurroundThread = nullptr;
void IntentionDetector::autoSurroundData(bool bStart) {
	if (bStart) {
		stSurroundThread = new AutoSurroundThread();
		stSurroundThread->run(m_pCallback);
	}
	else {
		stSurroundThread->stop();
		delete stSurroundThread;
		stSurroundThread = nullptr;
	}
}
